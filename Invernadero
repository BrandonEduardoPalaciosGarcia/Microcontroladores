#include <xc.h>
#include <pic16f18857.h>
#include "config.h" //Configurations Bits
#include <stdio.h> //LCD
#define _XTAL_FREQ 32000000 //Definimos frecuencia del Oscilador para usar delays
#include "Librerias.h" //Incluimos librerías
#include "flex_lcd.h" //Añadimos libreria de LCD
//Variables Globales************************************************************
int dato, dato1[4];//Variables para recibir datos
unsigned int tmr0,tmr1;//Variable de timers
unsigned char buffer1[16];//Buffer LCD
int ref=30,j=0,i=0;
int adc1,adc2,adc;
float temp1[4], temp2[4];
int a,energia=0,t;
float b, angulo;
float e,P,I,Iant,T=1,U;
int Kp=2, Ti=4;
int BT=0,BD=0;
int temp;
//Macros************************************************************************

//Funciones*********************************************************************
void __interrupt() ISR(void);
void retardo(void);
void Delay(void);
void TMR0_Delay(unsigned int delay);
//Main**************************************************************************
void main(void) {
    //PPS***********************************************************************
    RC6PPS=0x10;//TX->RC6
    RXPPS=0x17;//RX->RC7
    INTPPS=0x0F;//INT->RB7
    //ANSEL*********************************************************************
    ANSELB=0;//Puerto B como digital
    ANSELA=0;//Puerto A como digital
    ANSELC=0;//Puerto C como digital
    ANSC4=1;//RC4 como analógico
    ANSC5=1;//RC5 como analógico
    //TRIS**********************************************************************
    TRISC6=0;//Tx como salida
    TRISC7=1;//Rx como entrada
    TRISC4=1;//RC4 como entrada
    TRISC5=1;//RC5 como entrada
    TRISB5=0;//TRIAC
    TRISB2=0;//TRIAC
    TRISB1=0;//TRIAC
    TRISB7=1;//Detector cruce por cero
    //LCD***********************************************************************
    Lcd_Init();//Inicializar LCD
    Lcd_Cmd(LCD_CLEAR );//Limpiar LCD
    Lcd_Cmd(LCD_CURSOR_OFF );//Apagar el cursor
    __delay_ms(100);
    //Inicialización************************************************************
    ADC_Init();//Inicializamos ADC
    TMR0_Init();//Inicializamos TMR0
    TMR1_Init();//Inicializamos TMR1
    EUSART_Init();//Inicializamos EUSART
    TMR0Interrupt_Enabled();//Habilitamos interrupcion por TMR0 cada 1ms
    INTInterrupt_Enabled(1);//Habilitamos interrupción INT por flanco de subida
    //TMR1Interrupt_Enabled();
    Interrupt_Enabled();//Habilitamos interrupciones
    //TMR1_Enabled();
    //Ciclo infinito************************************************************
    while(1){
        adc2=ADC_Read(ANC5);
        temp=((adc2*5)/10.24);//Calculamos temperatura
        //sprintf(buffer1,"T=%0.1f",temp); // Imprimir variables 
        //Lcd_Out2(1,0,buffer1);
        e=ref-temp;//Obtenemos error
        P=Kp*e;//Calculamos la ganancia P
        if(U<80){//Limitamos el integrador para que no aumente 
          I=Iant+((Kp*T/Ti)*e);//Formula para obtener el integrador
          Iant=I;//Guardamos el Iant
        }
        else{I=Iant;}
        U=P+I;//Ganancia del sistema
        if (U<=2){U=2;}//Limitamos la ganancia del sistema
        if (U>=80){U=80;}
        angulo=(U*-1)+82;//Obtenemos angulo de 2 a 80
        energia =((U-2)*100)/78;//Obtenemos energia del 0 al 100%
        sprintf(buffer1,"Ti=%02d",Ti); // Imprimir variables 
        Lcd_Out2(1,0,buffer1);
        sprintf(buffer1,"Kp=%02d",Kp); // Imprimir variables 
        Lcd_Out2(1,8,buffer1);
        sprintf(buffer1,"T=%02d",temp); // Imprimir variables 
        Lcd_Out2(2,0,buffer1);
        sprintf(buffer1,"R=%02d",ref); // Imprimir variables 
        Lcd_Out2(2,8,buffer1);
        if (BT == 1){
            EUSART_TX(temp);
            BT=0;
        }
        if (BT == 2){
            EUSART_TX(energia);
            BT=0;
        }
        dato=RC1REG;//Lee dato recibido
      if(BD==1){
      if (dato <= 50){(Kp=dato);}
      if (dato >= 59 && dato <= 99){Ti=(dato-59);}
      if (dato >= 100 && dato <= 127){ref=((dato-100))+23;}}
      if(dato==65){TMR0_Enabled();BD=1;}
    }
    return;
}
//Funciones*********************************************************************
void retardo(void){
    b =((angulo*8.33)/180)*1000;//Valor del angulo de disparo en us
    while(a<b){//tiempo de espera variable segun el angulo
    __delay_us(100); // tiempo de espera
    a=a+100; // incremento de a para alcanzar el angulo de disparo
    }
    a=0; // se limpia a para un nuevo angulo 
}

//Interrupciones****************************************************************
void __interrupt() ISR(void){
    if (PIR0bits.TMR0IF==1){//Interrupción por TMR0 cada 1ms
      tmr0++;//Aumenta variable cada 1ms
      if (tmr0==500){
          BT=1;
      }
      if (tmr0 == 1000){
          BT=2;
          tmr0=0;
      }
      PIR0bits.TMR0IF=0;//Limpiamos bandera TMR0 
    }
    if (PIR3bits.RCIF==1){//Interrupción por RX
      dato=RC1REG;//Lee dato recibido
      PIR3bits.RCIF=0;//Limpiamos bandera
    }
      if(PIR0bits.INTF==1){//Interrupción INT (Cruce por zero)
      retardo();
      //Delay();
      LATB5=1;//Activamos TRIACS
      LATB2=1;
      LATB1=1;
      __delay_us(300);//Mantiene el TRIAC prendido
      LATB5=0;//Desactivamos TRIACS
      LATB2=0;
      LATB1=0;
      PIR0bits.INTF=0;//Limpia la bandera
    } 
    if (PIR4bits.TMR1IF==1){
        tmr1++;
        //if(tmr1==61){//Cada 0.5 s 
         // tmr1=0;
        //}
        PIR4bits.TMR1IF=0;
    }
}
